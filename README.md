# LeoEcsExtensions
LeoEcsExtensions is a set of extensions for the LeoECS framework, such as SystemGroups, UnityBridge, and others.

## Installation
todo

# ExtensionMethods
#### EcsEntity NewEntityWith&lt;T&gt;(this EcsWorld world)

This method creates a new entity with a component of type T. This method calls the `EcsEntity.Get<T>()` method. This can be useful when you need to create an entity with a single tag component that does not contain any data inside. 
For example:
```c#
var entity = _world.NewEntityWith<RequestCreateEnemyTag>();
```
<br>

#### EcsEntity NewEntityWith&lt;T&gt;(this EcsWorld world, T component)
This method creates a new entity with the component passed through the parameter. This method calls the `EcsEntity.Replace()` method. This can be used when you need to create a new entity, with a single component containing some data.
For example:
```c#
var requestComponent = new RequestCreateEnemyWithDataComponent
{
    Name = "Enemy",
    Health = 100,
    BehaviourType = EnemyBehaviourType.Agressive
};
var entity = _world.NewEntityWith(requestComponent);
```

#### void ForEachEntity(this EcsFilter filter, Action&lt;EcsEntity&gt; action)
This method executes the Action passed through the parameter for each entity from the filter. For example:
```c#
public sealed class ExampleSystem : IEcsRunSystem
{
    private readonly EcsFilter<DestroyEnemyTag> _destroyEnemyFilter = null;
    
    private readonly Action<EcsEntity> _destroyEnemyAction = 
        entity => enemy.Destroy();
    
    public void Run()
    {
        if (_destroyEnemyFilter.IsEmpty())
            return;
    
        _destroyEnemyFilter.ForEachEntity(_destroyEnemyAction);
    }
}
```

#### void ForAllFirstComponent&lt;T&gt;(this EcsFilter&lt;T&gt; filter, Action&lt;T&gt; action)
This method executes the Action passed through the parameter for each component obtained using `Get1()` from the filter. This can be useful when you need to do something with a single component in the filter.
For example:
```c#
public sealed class ExampleSystem : IEcsRunSystem
{
    private readonly EcsWorld _world = null;
    private readonly EcsFilter<RequestCreateEnemyWithDataComponent> _createEnemyFilter = null;
    
    private readonly Action<RequestCreateEnemyWithDataComponent> _createEnemyAction = 
        enemyData =>
        {
            var enemyComponent = new EnemyComponent
            {
                Name = enemyData.Name,
                Health = enemyData.Health,
                BehaviourType = enemyData.BehaviourType
            };

            _world.NewEntityWith(enemyComponent);
        };
    
    public void Run()
    {
        if (_createEnemyFilter.IsEmpty())
            return;
    
        _createEnemyFilter.ForAllFirstComponent(_createEnemyAction);
    }
}
```

# SystemGroups
_Coming soon..._

# UnityBridge

UnityBridge  is a bridge between Unity and ECS, allowing you to work with collisions, triggers, and the EventSystem as components in ECS.

## How to use
You need to add to the end of `EcsSystems` the systems required for UnityBridge to work. The easiest way to do this is to use the static `AddAllUnityBridgeSystemsTo` method of the `UnityBridge` class. For example:
```c#
private void Init()
{
    _world = new EcsWorld();
    _updateSystems = new EcsSystems(_world, "UpdateSystems");

    UnityBridge.AddAllUnityBridgeSystemsTo(_updateSystems);
            
    _updateSystems.Init();
}
```

If you only need to use EventSystem or Physics, you can use the static methods `AddEventSystemBridgeSystemsTo` and `AddPhysicsBridgeSystemsTo` in a similar way.

### Collision and Trigger detection
To work with collision and trigger detection, the systems responsible for this will create entities with the necessary components with a lifetime of one frame.

These components are:
```
CollisionEnterComponent
CollisionExitComponent
CollisionStayComponent

TriggerEnterComponent
TriggerExitComponent
TriggerStayComponent
```

You will need to use `EcsFilter`s to use them. For example:
```c#
public sealed class ExampleSystem : IEcsRunSystem
{
    private readonly EcsFilter<TriggerEnterComponent> _triggerEnterFilter = null;
    
    public void Run()
    {
        if (_triggerEnterFilter.IsEmpty())
            return;

        foreach (var index in _triggerEnterFilter)
        {
            var triggerEnterComponent = _triggerEnterFilter.Get1(index);
            var gameObjectName = triggerEnterComponent.Collider.name;
            
            Debug.Log($"GameObject named {gameObjectName} entered the trigger.");
        }
    }
}
```

### EventSystem
Working with EventSystem events is similar to working with Physics events. For each event generated by the EventSystem, a new entity is created with a component that provides data for this event.

These components are:
```
PointerEnterComponent
PointerExitComponent
PointerDownComponent
PointerUpComponent
PointerClickComponent

BeginDragComponent
EndDragComponent
DragComponent
DropComponent
```

Just like when working with Physics, you need to use `EcsFilter`s to get the components. For example:
```c#
public sealed class ExampleSystem : IEcsRunSystem
{
    private readonly EcsFilter<PointerClickComponent> _pointerClickFilter = null;
    
    public void Run()
    {
        if (_pointerClickFilter.IsEmpty())
            return;

        foreach (var index in _pointerClickFilter)
        {
            var pointerClickComponent = _pointerClickFilter.Get1(index);
            var pointerEventData = pointerClickComponent.PointerEventData;
            var clickedObjectName = pointerEventData.pointerClick.name;
            
            Debug.Log($"You clicked on a GameObject named {clickedObjectName}.");
        }
    }
}
```

### Raycasting
There are two systems that launch raycasts: `RaycastSystem` and `RaycastAllSystem`. In order for these systems to make a raycast, you need to create an entity with the `RaycastRequestComponent` and `RaycastAllRequestComponent` components, respectively.
<br>
<br>
After the systems responsible for the raycast are executed, the response component is added to the entity with the request component. These components are `RaycastResultComponent` and `RaycastAllResultComponent`.
<br>
The entity with the request component at the end of the frame will be deleted, as will the components that provide the Physics and EventSystem events.
<br>
<br>
The following example will help you understand how it works.

#### Single raycast
Creating a system for requesting a raycast:
```c#
public sealed class RequestRaycastSystem : IEcsRunSystem
{
    private readonly EcsWorld _world = null;
    
    public void Run()
    {
        if (Input.GetMouseButtonDown(0))
        {
            var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            var distance = float.PositiveInfinity;
            var layerMask = LayerMask.GetMask("Default");
            
            var entity = _world.NewEntity();
            var raycastRequestComponent = new RaycastRequestComponent
            {
                Ray = ray,
                Distance = distance,
                LayerMask = layerMask
            };
            entity.Replace(raycastRequestComponent);
        }
    }
}
```

Creating a system that receives the result of the raycast:
```c#
public sealed class ResolveRaycastSystem : IEcsRunSystem
{
    private readonly EcsFilter<RaycastRequestComponent, RaycastResultComponent> _raycastFilter = null;
    
    public void Run()
    {
        if (_raycastFilter.IsEmpty())
            return;

        var raycastResultComponent = _raycastFilter.Get2(0);
        var raycastHit = raycastResultComponent.RaycastHit;
        var hitedObjectName = raycastHit.collider.name;
        
        Debug.Log($"You hit on a GameObject named {hitedObjectName}");
    }
}
```

Adding systems to EcsSystems in the following order:
```c#
_updateSystems
    .Add(new RequestRaycastSystem())
    .Add(new RaycastSystem())
    .Add(new ResolveRaycastSystem());
```

#### RaycastAll
Creating a system for requesting a raycast:
```c#
public sealed class RequestRaycastAllSystem : IEcsRunSystem
{
    private readonly EcsWorld _world = null;

    private readonly RaycastHit[] _raycastHits = new RaycastHit[8];

    public void Run()
    {
        if (Input.GetMouseButtonDown(0))
        {
            var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            var distance = float.PositiveInfinity;
            var layerMask = LayerMask.GetMask("Default");
            
            var entity = _world.NewEntity();
            var raycastAllRequestComponent = new RaycastAllRequestComponent
            {
                Ray = ray,
                Distance = distance,
                LayerMask = layerMask,
                RaycastHits = _raycastHits
            };
            entity.Replace(raycastAllRequestComponent);
        }
    }
}
```

Creating a system that receives the result of the raycast:
```c#
public sealed class ResolveRaycastAllSystem : IEcsRunSystem
{
    private readonly EcsFilter<RaycastAllRequestComponent, RaycastAllResultComponent> _raycastFilter = null;
    
    public void Run()
    {
        if (_raycastFilter.IsEmpty())
            return;

        var raycastResultComponent = _raycastFilter.Get2(0);
        var hitsCount = raycastResultComponent.HitsCount;
        var raycastHits = raycastResultComponent.RaycastHits;

        for (var i = 0; i < hitsCount; i++)
        {
            var hitedObjectName = raycastHits[i].collider.name;
            Debug.Log($"You hit on a GameObject named {hitedObjectName}");
        }
    }
}
```

Adding systems to EcsSystems in the following order:
```c#
_updateSystems
    .Add(new RequestRaycastAllSystem())
    .Add(new RaycastAllSystem())
    .Add(new ResolveRaycastAllSystem());
```