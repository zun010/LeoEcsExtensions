# LeoEcsExtensions
LeoEcsExtensions is a set of extensions for the LeoECS framework, such as SystemGroups, UnityBridge, and others.

## Installation
todo

# ExtensionMethods
todo

# UnityBridge

UnityBridge  is a bridge between Unity and ECS, allowing you to work with collisions, triggers, and the EventSystem as components in ECS.

## How to use
You need to add to the end of `EcsSystems` the systems required for UnityBridge to work. The easiest way to do this is to use the static `AddAllUnityBridgeSystemsTo` method of the `UnityBridge` class. For example:
```c#
private void Init()
{
    _world = new EcsWorld();
    _updateSystems = new EcsSystems(_world, "UpdateSystems");

    UnityBridge.AddAllUnityBridgeSystemsTo(_updateSystems);
            
    _updateSystems.Init();
}
```

If you only need to use EventSystem or Physics, you can use the static methods `AddEventSystemBridgeSystemsTo` and `AddPhysicsBridgeSystemsTo` in a similar way.

### Collision and Trigger detection
To work with collision and trigger detection, the systems responsible for this will create entities with the necessary components with a lifetime of one frame.

These components are:
```
CollisionEnterComponent
CollisionExitComponent
CollisionStayComponent

TriggerEnterComponent
TriggerExitComponent
TriggerStayComponent
```

You will need to use `EcsFilter`s to use them. For example:
```c#
public sealed class ExampleSystem : IEcsRunSystem
{
    private readonly EcsFilter<TriggerEnterComponent> _triggerEnterFilter = null;
    
    public void Run()
    {
        if (_triggerEnterFilter.IsEmpty())
            return;

        foreach (var index in _triggerEnterFilter)
        {
            var triggerEnterComponent = _triggerEnterFilter.Get1(index);
            var gameObjectName = triggerEnterComponent.Collider.name;
            
            Debug.Log($"GameObject named {gameObjectName} entered the trigger.");
        }
    }
}
```

### EventSystem
Working with EventSystem events is similar to working with Physics events. For each event generated by the EventSystem, a new entity is created with a component that provides data for this event.

These components are:
```
PointerEnterComponent
PointerExitComponent
PointerDownComponent
PointerUpComponent
PointerClickComponent

BeginDragComponent
EndDragComponent
DragComponent
DropComponent
```

Just like when working with Physics, you need to use `EcsFilter`s to get the components. For example:
```c#
public sealed class ExampleSystem : IEcsRunSystem
{
    private readonly EcsFilter<PointerClickComponent> _pointerClickFilter = null;
    
    public void Run()
    {
        if (_pointerClickFilter.IsEmpty())
            return;

        foreach (var index in _pointerClickFilter)
        {
            var pointerClickComponent = _pointerClickFilter.Get1(index);
            var pointerEventData = pointerClickComponent.PointerEventData;
            var clickedObjectName = pointerEventData.pointerClick.name;
            
            Debug.Log($"You clicked on a GameObject named {clickedObjectName}.");
        }
    }
}
```

### Raycasting
There are two systems that launch raycasts: `RaycastSystem` and `RaycastAllSystem`. In order for these systems to make a raycast, you need to create an entity with the `RaycastRequestComponent` and `RaycastAllRequestComponent` components, respectively.
<br>
<br>
After the systems responsible for the raycast are executed, the response component is added to the entity with the request component. These components are `RaycastResultComponent` and `RaycastAllResultComponent`.
<br>
The entity with the request component at the end of the frame will be deleted, as will the components that provide the Physics and EventSystem events.
<br>
<br>
The following example will help you understand how it works.

#### Single raycast
Creating a system for requesting a raycast:
```c#
public sealed class RequestRaycastSystem : IEcsRunSystem
{
    private readonly EcsWorld _world = null;
    
    public void Run()
    {
        if (Input.GetMouseButtonDown(0))
        {
            var ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            var distance = float.PositiveInfinity;
            var layerMask = LayerMask.GetMask("Default");
            
            var entity = _world.NewEntity();
            var raycastRequestComponent = new RaycastRequestComponent
            {
                Ray = ray,
                Distance = distance,
                LayerMask = layerMask
            };
            entity.Replace(raycastRequestComponent);
        }
    }
}
```

Creating a system that receives the result of the raycast:
```c#
public sealed class ResolveRaycastSystem : IEcsRunSystem
{
    private readonly EcsFilter<RaycastRequestComponent, RaycastResultComponent> _raycastFilter = null;
    
    public void Run()
    {
        if (_raycastFilter.IsEmpty())
            return;

        var raycastResultComponent = _raycastFilter.Get2(0);
        var raycastHit = raycastResultComponent.RaycastHit;
        var hitedObjectName = raycastHit.collider.name;
        
        Debug.Log($"You hit on a GameObject named {hitedObjectName}");
    }
}
```

Adding systems to EcsSystems in the following order:
```c#
_updateSystems
    .Add(new RequestRaycastSystem())
    .Add(new RaycastSystem())
    .Add(new ResolveRaycastSystem());
```

#### RaycastAll
Creating a system for requesting a raycast:
```c#
// todo
```

Creating a system that receives the result of the raycast:
```c#
// todo
```

Adding systems to EcsSystems in the following order:
```c#
// todo
```